# è§†é¢‘æ¸²æŸ“åŸºç¡€çŸ¥è¯† - ä»å…¥é—¨åˆ°ç²¾é€š

**ç›®æ ‡è¯»è€…**ï¼šå¯¹è§†é¢‘æ¸²æŸ“ä¸ç†Ÿæ‚‰çš„å¼€å‘è€…  
**å­¦ä¹ è·¯å¾„**ï¼šåŸºç¡€æ¦‚å¿µ â†’ è½¯ä»¶æ¸²æŸ“ â†’ ç¡¬ä»¶æ¸²æŸ“ â†’ é›¶æ‹·è´ä¼˜åŒ–  
**é¢„è®¡å­¦ä¹ æ—¶é—´**ï¼š60-90 åˆ†é’Ÿ

---

## ğŸ“š ç›®å½•

1. [ç¬¬ä¸€ç« ï¼šä»€ä¹ˆæ˜¯è§†é¢‘æ¸²æŸ“](#ç¬¬ä¸€ç« ä»€ä¹ˆæ˜¯è§†é¢‘æ¸²æŸ“)
2. [ç¬¬äºŒç« ï¼šè§†é¢‘æ•°æ®æ ¼å¼](#ç¬¬äºŒç« è§†é¢‘æ•°æ®æ ¼å¼)
3. [ç¬¬ä¸‰ç« ï¼šè½¯ä»¶æ¸²æŸ“è¯¦è§£](#ç¬¬ä¸‰ç« è½¯ä»¶æ¸²æŸ“è¯¦è§£)
4. [ç¬¬å››ç« ï¼šç¡¬ä»¶æ¸²æŸ“è¯¦è§£](#ç¬¬å››ç« ç¡¬ä»¶æ¸²æŸ“è¯¦è§£)
5. [ç¬¬äº”ç« ï¼šæ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#ç¬¬äº”ç« æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
6. [ç¬¬å…­ç« ï¼šZenPlay å®ç°](#ç¬¬å…­ç« zenplay-å®ç°)
7. [ç¬¬ä¸ƒç« ï¼šå®æˆ˜æ¼”ç»ƒ](#ç¬¬ä¸ƒç« å®æˆ˜æ¼”ç»ƒ)

---

## ç¬¬ä¸€ç« ï¼šä»€ä¹ˆæ˜¯è§†é¢‘æ¸²æŸ“

### 1.1 æœ€ç®€å•çš„ç†è§£

**æ¸²æŸ“ = æŠŠè§†é¢‘æ•°æ®æ˜¾ç¤ºåˆ°å±å¹•ä¸Š**

æƒ³è±¡ä¸€ä¸‹çœ‹ç”µå½±çš„è¿‡ç¨‹ï¼š

```
ç”µå½±æ–‡ä»¶ (.mp4)
    â†“
[è§£ç ] æŠŠå‹ç¼©çš„æ•°æ®å˜æˆä¸€å¸§å¸§å›¾ç‰‡
    â†“
æ¯å¸§å›¾ç‰‡ (åŸå§‹åƒç´ æ•°æ®)
    â†“
[æ¸²æŸ“] æŠŠå›¾ç‰‡æ˜¾ç¤ºåˆ°å±å¹•ä¸Š â† è¿™å°±æ˜¯æ¸²æŸ“ï¼
    â†“
ä½ çœ‹åˆ°çš„ç”»é¢
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦"æ¸²æŸ“"è¿™ä¸€æ­¥ï¼Ÿ

ä½ å¯èƒ½ä¼šæƒ³ï¼šå›¾ç‰‡æ•°æ®å·²ç»æœ‰äº†ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥æ˜¾ç¤ºï¼Ÿ

**åŸå› **ï¼š
1. **æ ¼å¼è½¬æ¢**ï¼šè§†é¢‘å¸§é€šå¸¸æ˜¯ YUV æ ¼å¼ï¼Œå±å¹•éœ€è¦ RGB æ ¼å¼
2. **ç¼©æ”¾**ï¼šè§†é¢‘åˆ†è¾¨ç‡å¯èƒ½å’Œçª—å£å¤§å°ä¸ä¸€è‡´
3. **åŒæ­¥**ï¼šéœ€è¦æ§åˆ¶æ˜¾ç¤ºæ—¶æœºï¼ˆæ¯ç§’ 24/30/60 å¸§ï¼‰
4. **æ€§èƒ½**ï¼šéœ€è¦é«˜æ•ˆå¤„ç†æ‰èƒ½æµç•…æ’­æ”¾

### 1.3 ä¸¤ç§æ¸²æŸ“æ–¹å¼

| æ–¹å¼ | å·¥ä½œä½ç½® | é€Ÿåº¦ | åŠŸè€— | å…¼å®¹æ€§ |
|------|---------|------|------|--------|
| **è½¯ä»¶æ¸²æŸ“** | CPU | æ…¢ | é«˜ | âœ… 100% |
| **ç¡¬ä»¶æ¸²æŸ“** | GPU | å¿« | ä½ | âš ï¸ éœ€è¦æ”¯æŒ |

**ç±»æ¯”**ï¼š
- è½¯ä»¶æ¸²æŸ“ = ä½ ç”¨æ‰‹å·¥è®¡ç®—å™¨ç®—æ•°å­¦é¢˜ï¼ˆæ…¢ä½†è‚¯å®šèƒ½ç®—ï¼‰
- ç¡¬ä»¶æ¸²æŸ“ = ç”¨ä¸“ä¸šè®¡ç®—å™¨ç®—é¢˜ï¼ˆå¿«ä½†éœ€è¦ä¹°è®¾å¤‡ï¼‰

---

## ç¬¬äºŒç« ï¼šè§†é¢‘æ•°æ®æ ¼å¼

### 2.1 ä»€ä¹ˆæ˜¯"ä¸€å¸§"ï¼Ÿ

**ä¸€å¸§ = ä¸€å¼ å›¾ç‰‡**

è§†é¢‘å°±æ˜¯å¿«é€Ÿè¿ç»­æ’­æ”¾çš„å›¾ç‰‡ï¼š
- ç”µå½±ï¼š24 å¸§/ç§’ï¼ˆæ¯ç§’ 24 å¼ å›¾ç‰‡ï¼‰
- è§†é¢‘ï¼š30 æˆ– 60 å¸§/ç§’
- æ¸¸æˆï¼š60-144 å¸§/ç§’

### 2.2 åƒç´ æ•°æ®çš„ä¸¤ç§æ ¼å¼

#### RGB æ ¼å¼ï¼ˆå±å¹•ä½¿ç”¨ï¼‰

```
ä¸€ä¸ªåƒç´  = çº¢è‰² + ç»¿è‰² + è“è‰²

R   G   B
255 0   0   = çº¯çº¢è‰²
0   255 0   = çº¯ç»¿è‰²
0   0   255 = çº¯è“è‰²
255 255 255 = ç™½è‰²
0   0   0   = é»‘è‰²
```

#### YUV æ ¼å¼ï¼ˆè§†é¢‘ä½¿ç”¨ï¼‰

```
ä¸€ä¸ªåƒç´  = Y(äº®åº¦) + U(è“è‰²å·®) + V(çº¢è‰²å·®)

ä¸ºä»€ä¹ˆè§†é¢‘ç”¨ YUVï¼Ÿ
1. äººçœ¼å¯¹äº®åº¦æ•æ„Ÿï¼Œå¯¹é¢œè‰²ä¸æ•æ„Ÿ
2. å¯ä»¥å‹ç¼© U å’Œ Vï¼ŒèŠ‚çœç©ºé—´
3. 1920x1080 çš„è§†é¢‘ï¼ŒYUV æ¯” RGB å° 50%
```

**å…³é”®ç‚¹**ï¼šè§†é¢‘è§£ç åæ˜¯ YUVï¼Œä½†å±å¹•éœ€è¦ RGBï¼Œæ‰€ä»¥éœ€è¦è½¬æ¢ï¼

### 2.3 YUV â†’ RGB è½¬æ¢å…¬å¼

```cpp
// æ•°å­¦å…¬å¼ï¼ˆä¸ç”¨è®°ï¼‰
R = Y + 1.402 * (V - 128)
G = Y - 0.344 * (U - 128) - 0.714 * (V - 128)
B = Y + 1.772 * (U - 128)

// è¿™ä¸ªè½¬æ¢è¿‡ç¨‹æ˜¯æ¸²æŸ“çš„æ ¸å¿ƒå·¥ä½œä¹‹ä¸€
```

---

## ç¬¬ä¸‰ç« ï¼šè½¯ä»¶æ¸²æŸ“è¯¦è§£

### 3.1 ä»€ä¹ˆæ˜¯è½¯ä»¶æ¸²æŸ“ï¼Ÿ

**å®šä¹‰**ï¼šç”¨ CPU å®Œæˆæ‰€æœ‰æ¸²æŸ“å·¥ä½œ

```
è§†é¢‘å¸§ (YUV)
    â†“
[CPU å·¥ä½œ]
1. åˆ†é…å†…å­˜å­˜å‚¨ RGB æ•°æ®
2. é€ä¸ªåƒç´ è½¬æ¢ YUV â†’ RGB  â† æœ€æ…¢çš„éƒ¨åˆ†ï¼
3. æŠŠ RGB æ•°æ®å¤åˆ¶åˆ°æ˜¾å­˜
    â†“
å±å¹•æ˜¾ç¤º
```

### 3.2 è½¯ä»¶æ¸²æŸ“çš„å®Œæ•´æµç¨‹

#### æ­¥éª¤ 1ï¼šè§£ç å¾—åˆ° YUV å¸§

```cpp
// FFmpeg è§£ç 
AVFrame* frame = av_frame_alloc();
avcodec_receive_frame(decoder, frame);

// æ­¤æ—¶ frame åŒ…å« YUV æ•°æ®
// frame->data[0] = Y å¹³é¢ï¼ˆäº®åº¦ï¼‰
// frame->data[1] = U å¹³é¢ï¼ˆè“è‰²å·®ï¼‰
// frame->data[2] = V å¹³é¢ï¼ˆçº¢è‰²å·®ï¼‰
```

#### æ­¥éª¤ 2ï¼šåˆ›å»º SDL çº¹ç†ï¼ˆç›®æ ‡ï¼‰

```cpp
// SDL2 çº¹ç†ï¼ˆåœ¨æ˜¾å­˜ä¸­ï¼‰
SDL_Texture* texture = SDL_CreateTexture(
    renderer,
    SDL_PIXELFORMAT_IYUV,  // æˆ– SDL_PIXELFORMAT_RGB24
    SDL_TEXTUREACCESS_STREAMING,
    width, height
);
```

#### æ­¥éª¤ 3ï¼šYUV â†’ RGB è½¬æ¢ï¼ˆCPU å¯†é›†ï¼‰

```cpp
// æ–¹æ³• 1ï¼šè®© SDL è‡ªåŠ¨è½¬æ¢ï¼ˆç®€å•ä½†æ…¢ï¼‰
SDL_UpdateYUVTexture(texture, nullptr,
    frame->data[0], frame->linesize[0],  // Y
    frame->data[1], frame->linesize[1],  // U
    frame->data[2], frame->linesize[2]); // V

// æ–¹æ³• 2ï¼šæ‰‹åŠ¨è½¬æ¢ï¼ˆæ›´å¿«ä½†å¤æ‚ï¼‰
uint8_t* rgb_buffer = new uint8_t[width * height * 3];
for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
        // å¯¹æ¯ä¸ªåƒç´ æ‰§è¡Œ YUV â†’ RGB è½¬æ¢
        int Y = frame->data[0][y * frame->linesize[0] + x];
        int U = frame->data[1][(y/2) * frame->linesize[1] + (x/2)];
        int V = frame->data[2][(y/2) * frame->linesize[2] + (x/2)];
        
        // è½¬æ¢å…¬å¼
        rgb_buffer[offset + 0] = CLIP(Y + 1.402 * (V - 128));
        rgb_buffer[offset + 1] = CLIP(Y - 0.344 * (U - 128) - 0.714 * (V - 128));
        rgb_buffer[offset + 2] = CLIP(Y + 1.772 * (U - 128));
    }
}
```

#### æ­¥éª¤ 4ï¼šå¤åˆ¶åˆ°æ˜¾å­˜

```cpp
// æŠŠ CPU å†…å­˜çš„ RGB æ•°æ®å¤åˆ¶åˆ° GPU æ˜¾å­˜
SDL_UpdateTexture(texture, nullptr, rgb_buffer, width * 3);
```

#### æ­¥éª¤ 5ï¼šæ¸²æŸ“åˆ°å±å¹•

```cpp
// ä»çº¹ç†æ¸²æŸ“åˆ°çª—å£
SDL_RenderClear(renderer);
SDL_RenderCopy(renderer, texture, nullptr, nullptr);
SDL_RenderPresent(renderer);
```

### 3.3 è½¯ä»¶æ¸²æŸ“çš„æ€§èƒ½ç“¶é¢ˆ

**1080p è§†é¢‘çš„è®¡ç®—é‡**ï¼š

```
åˆ†è¾¨ç‡ï¼š1920 x 1080 = 2,073,600 ä¸ªåƒç´ 
å¸§ç‡ï¼š30 fps

æ¯ç§’éœ€è¦å¤„ç†çš„åƒç´ ï¼š
2,073,600 Ã— 30 = 62,208,000 åƒç´ /ç§’

æ¯ä¸ªåƒç´ éœ€è¦ï¼š
- 3 æ¬¡å†…å­˜è¯»å–ï¼ˆY, U, Vï¼‰
- 5-10 æ¬¡æµ®ç‚¹æ•°è¿ç®—ï¼ˆè½¬æ¢å…¬å¼ï¼‰
- 3 æ¬¡å†…å­˜å†™å…¥ï¼ˆR, G, Bï¼‰

æ€»è®¡ï¼šæ¯ç§’ ~500,000,000 æ¬¡å†…å­˜æ“ä½œ + ~1,000,000,000 æ¬¡è¿ç®—
```

**ä¸ºä»€ä¹ˆæ…¢**ï¼š
1. CPU è¦é€ä¸ªå¤„ç†åƒç´ ï¼ˆä¸²è¡Œï¼‰
2. YUV â†’ RGB è½¬æ¢è®¡ç®—å¯†é›†
3. å†…å­˜æ‹·è´ï¼ˆYUV â†’ RGB â†’ æ˜¾å­˜ï¼‰

**CPU å ç”¨ç‡**ï¼š
- 1080p @ 30fpsï¼š20-40% CPU
- 4K @ 60fpsï¼š60-100% CPUï¼ˆåŸºæœ¬è·‘ä¸åŠ¨ï¼‰

---

## ç¬¬å››ç« ï¼šç¡¬ä»¶æ¸²æŸ“è¯¦è§£

### 4.1 ä»€ä¹ˆæ˜¯ç¡¬ä»¶æ¸²æŸ“ï¼Ÿ

**å®šä¹‰**ï¼šç”¨ GPU å®Œæˆæ¸²æŸ“å·¥ä½œ

**ä¸ºä»€ä¹ˆ GPU å¿«**ï¼Ÿ

```
CPU çš„ç‰¹ç‚¹ï¼š
- 4-16 ä¸ªæ ¸å¿ƒ
- æ“…é•¿å¤æ‚é€»è¾‘
- ä¸²è¡Œå¤„ç†

GPU çš„ç‰¹ç‚¹ï¼š
- æ•°ç™¾åˆ°æ•°åƒä¸ªæ ¸å¿ƒï¼
- æ“…é•¿ç®€å•é‡å¤è®¡ç®—
- å¹¶è¡Œå¤„ç†

ä¾‹å­ï¼š
è½¬æ¢ 1920x1080 çš„å›¾ç‰‡ï¼ˆ200 ä¸‡åƒç´ ï¼‰

CPU: ä¸€ä¸ªæ ¸å¿ƒä¾æ¬¡å¤„ç† 200 ä¸‡æ¬¡
     è€—æ—¶ï¼š200 ä¸‡ Ã· æ ¸å¿ƒé€Ÿåº¦ = å‡ åæ¯«ç§’

GPU: 2000 ä¸ªæ ¸å¿ƒåŒæ—¶å¤„ç†ï¼Œæ¯ä¸ªå¤„ç† 1000 åƒç´ 
     è€—æ—¶ï¼š1000 Ã· æ ¸å¿ƒé€Ÿåº¦ = å‡ æ¯«ç§’
```

### 4.2 ç¡¬ä»¶æ¸²æŸ“çš„å®Œæ•´æµç¨‹

#### æ–¹å¼ 1ï¼šç¡¬ä»¶è§£ç  + ç¡¬ä»¶æ¸²æŸ“ï¼ˆæœ€å¿«ï¼‰

```
è§†é¢‘æ–‡ä»¶ (.mp4)
    â†“
[GPU ç¡¬ä»¶è§£ç å™¨]
ç›´æ¥è¾“å‡º GPU æ˜¾å­˜ä¸­çš„ YUV å¸§  â† å…³é”®ï¼æ•°æ®å·²åœ¨ GPU é‡Œ
    â†“
[GPU ç€è‰²å™¨ç¨‹åº]
åœ¨ GPU ä¸Šæ‰§è¡Œ YUV â†’ RGB è½¬æ¢  â† å¹¶è¡Œå¤„ç†ï¼Œè¶…å¿«
    â†“
[GPU ç›´æ¥æ¸²æŸ“]
ä¸éœ€è¦ CPU å‚ä¸ï¼Œä¸éœ€è¦æ‹·è´æ•°æ®
    â†“
å±å¹•æ˜¾ç¤º
```

#### æ–¹å¼ 2ï¼šè½¯ä»¶è§£ç  + ç¡¬ä»¶æ¸²æŸ“ï¼ˆæŠ˜ä¸­ï¼‰

```
è§†é¢‘æ–‡ä»¶ (.mp4)
    â†“
[CPU è½¯ä»¶è§£ç ]
è¾“å‡º CPU å†…å­˜ä¸­çš„ YUV å¸§
    â†“
[ä¸Šä¼ åˆ° GPU] â† éœ€è¦ä¸€æ¬¡æ‹·è´
YUV æ•°æ®ä» CPU å†…å­˜å¤åˆ¶åˆ° GPU æ˜¾å­˜
    â†“
[GPU ç€è‰²å™¨ç¨‹åº]
åœ¨ GPU ä¸Šæ‰§è¡Œ YUV â†’ RGB è½¬æ¢
    â†“
[GPU ç›´æ¥æ¸²æŸ“]
    â†“
å±å¹•æ˜¾ç¤º
```

### 4.3 GPU ç€è‰²å™¨ï¼ˆShaderï¼‰

**ä»€ä¹ˆæ˜¯ç€è‰²å™¨**ï¼Ÿ

ç€è‰²å™¨æ˜¯è¿è¡Œåœ¨ GPU ä¸Šçš„å°ç¨‹åºï¼Œå¯ä»¥å¯¹æ¯ä¸ªåƒç´ å¹¶è¡Œæ‰§è¡Œæ“ä½œã€‚

#### YUV â†’ RGB è½¬æ¢çš„ç€è‰²å™¨ä»£ç 

```hlsl
// HLSL (Direct3D 11 ç€è‰²å™¨è¯­è¨€)

// è¾“å…¥ï¼šYUV çº¹ç†
Texture2D<float> yTexture : register(t0);  // Y å¹³é¢
Texture2D<float> uTexture : register(t1);  // U å¹³é¢
Texture2D<float> vTexture : register(t2);  // V å¹³é¢

// è¾“å‡ºï¼šRGB åƒç´ 
float4 main(float2 texCoord : TEXCOORD) : SV_Target
{
    // 1. ä»çº¹ç†è¯»å– YUV å€¼
    float y = yTexture.Sample(sampler, texCoord).r;
    float u = uTexture.Sample(sampler, texCoord).r - 0.5;
    float v = vTexture.Sample(sampler, texCoord).r - 0.5;
    
    // 2. YUV â†’ RGB è½¬æ¢ï¼ˆå¹¶è¡Œæ‰§è¡Œï¼ï¼‰
    float r = y + 1.402 * v;
    float g = y - 0.344 * u - 0.714 * v;
    float b = y + 1.772 * u;
    
    // 3. è¿”å› RGB é¢œè‰²
    return float4(r, g, b, 1.0);
}
```

**å…³é”®ç‚¹**ï¼š
- è¿™ä¸ªå‡½æ•°å¯¹**æ¯ä¸ªåƒç´ **å¹¶è¡Œæ‰§è¡Œ
- 1920x1080 = 200 ä¸‡åƒç´ ï¼ŒGPU å¯ä»¥åŒæ—¶å¤„ç†
- CPU åªèƒ½ä¸€ä¸ªä¸€ä¸ªå¤„ç†

### 4.4 Direct3D 11 ç¡¬ä»¶æ¸²æŸ“æ­¥éª¤

#### æ­¥éª¤ 1ï¼šåˆ›å»º D3D11 è®¾å¤‡

```cpp
// åˆ›å»º GPU æ¥å£
ID3D11Device* device;
ID3D11DeviceContext* context;

D3D11CreateDevice(
    nullptr,                   // é»˜è®¤æ˜¾å¡
    D3D_DRIVER_TYPE_HARDWARE,  // ç¡¬ä»¶åŠ é€Ÿ
    nullptr,
    0,
    nullptr, 0,
    D3D11_SDK_VERSION,
    &device,
    nullptr,
    &context
);
```

#### æ­¥éª¤ 2ï¼šåˆ›å»ºçº¹ç†ï¼ˆåœ¨ GPU æ˜¾å­˜ä¸­ï¼‰

```cpp
// æè¿°çº¹ç†æ ¼å¼
D3D11_TEXTURE2D_DESC desc = {};
desc.Width = 1920;
desc.Height = 1080;
desc.Format = DXGI_FORMAT_R8_UNORM;  // å•é€šé“ 8 ä½ï¼ˆY/U/V å„ä¸€ä¸ªï¼‰
desc.Usage = D3D11_USAGE_DEFAULT;     // GPU è¯»å†™
desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;  // å¯ä»¥ä½œä¸ºç€è‰²å™¨è¾“å…¥

// åˆ›å»º Yã€Uã€V ä¸‰ä¸ªçº¹ç†
ID3D11Texture2D* yTexture;
ID3D11Texture2D* uTexture;
ID3D11Texture2D* vTexture;

device->CreateTexture2D(&desc, nullptr, &yTexture);
// ... ç±»ä¼¼åˆ›å»º U å’Œ V
```

#### æ­¥éª¤ 3ï¼šä¸Šä¼  YUV æ•°æ®åˆ° GPU

```cpp
// æ–¹æ³• 1ï¼šä» CPU å†…å­˜ä¸Šä¼ ï¼ˆè½¯ä»¶è§£ç çš„æƒ…å†µï¼‰
context->UpdateSubresource(
    yTexture,         // ç›®æ ‡çº¹ç†ï¼ˆGPU æ˜¾å­˜ï¼‰
    0,
    nullptr,
    frame->data[0],   // æºæ•°æ®ï¼ˆCPU å†…å­˜ï¼‰
    frame->linesize[0],
    0
);

// æ–¹æ³• 2ï¼šç›´æ¥ä½¿ç”¨ GPU è§£ç è¾“å‡ºï¼ˆé›¶æ‹·è´ï¼ï¼‰
// ç¡¬ä»¶è§£ç ç›´æ¥è¾“å‡º ID3D11Texture2D*ï¼Œæ— éœ€ä¸Šä¼ 
```

#### æ­¥éª¤ 4ï¼šè¿è¡Œç€è‰²å™¨ï¼ˆYUV â†’ RGBï¼‰

```cpp
// ç¼–è¯‘ç€è‰²å™¨
ID3DBlob* shaderBlob;
D3DCompileFromFile(L"yuv_to_rgb.hlsl", nullptr, nullptr,
    "main", "ps_5_0", 0, 0, &shaderBlob, nullptr);

ID3D11PixelShader* pixelShader;
device->CreatePixelShader(
    shaderBlob->GetBufferPointer(),
    shaderBlob->GetBufferSize(),
    nullptr,
    &pixelShader
);

// ç»‘å®šçº¹ç†åˆ°ç€è‰²å™¨
context->PSSetShaderResources(0, 1, &yTexture);
context->PSSetShaderResources(1, 1, &uTexture);
context->PSSetShaderResources(2, 1, &vTexture);

// è¿è¡Œç€è‰²å™¨
context->PSSetShader(pixelShader, nullptr, 0);
context->Draw(6, 0);  // ç»˜åˆ¶å…¨å±å››è¾¹å½¢ï¼ˆ2 ä¸ªä¸‰è§’å½¢ï¼‰
```

#### æ­¥éª¤ 5ï¼šå‘ˆç°åˆ°å±å¹•

```cpp
// äº¤æ¢ç¼“å†²åŒºï¼Œæ˜¾ç¤ºæ¸²æŸ“ç»“æœ
swapChain->Present(1, 0);  // 1 = VSync å¼€å¯
```

### 4.5 ç¡¬ä»¶è§£ç é›†æˆï¼ˆé›¶æ‹·è´çš„å…³é”®ï¼‰

**FFmpeg ç¡¬ä»¶è§£ç è¾“å‡º D3D11 çº¹ç†**ï¼š

```cpp
// 1. åˆ›å»ºç¡¬ä»¶è®¾å¤‡ä¸Šä¸‹æ–‡
AVBufferRef* hw_device_ctx = nullptr;
av_hwdevice_ctx_create(&hw_device_ctx, 
    AV_HWDEVICE_TYPE_D3D11VA,  // Direct3D 11 ç¡¬ä»¶åŠ é€Ÿ
    nullptr, nullptr, 0);

// 2. é…ç½®è§£ç å™¨ä½¿ç”¨ç¡¬ä»¶
AVCodecContext* codec_ctx = avcodec_alloc_context3(codec);
codec_ctx->hw_device_ctx = av_buffer_ref(hw_device_ctx);
codec_ctx->get_format = [](AVCodecContext*, const enum AVPixelFormat* fmt) {
    // é€‰æ‹©ç¡¬ä»¶åƒç´ æ ¼å¼
    return AV_PIX_FMT_D3D11;
};

// 3. è§£ç 
AVFrame* frame = av_frame_alloc();
avcodec_receive_frame(codec_ctx, frame);

// 4. è·å– D3D11 çº¹ç†ï¼ˆé›¶æ‹·è´ï¼ï¼‰
if (frame->format == AV_PIX_FMT_D3D11) {
    // frame->data[0] æ˜¯ ID3D11Texture2D*
    ID3D11Texture2D* texture = (ID3D11Texture2D*)frame->data[0];
    int index = (intptr_t)frame->data[1];  // çº¹ç†æ•°ç»„ç´¢å¼•
    
    // ç›´æ¥ä½¿ç”¨è¿™ä¸ªçº¹ç†æ¸²æŸ“ï¼Œæ— éœ€æ‹·è´ï¼
    context->PSSetShaderResources(0, 1, &texture);
}
```

**é›¶æ‹·è´çš„å¨åŠ›**ï¼š

```
ä¼ ç»Ÿæµç¨‹ï¼ˆ3 æ¬¡æ‹·è´ï¼‰ï¼š
è§†é¢‘æ–‡ä»¶ â†’ [è§£ç ] â†’ CPU å†…å­˜ YUV
                      â†“ æ‹·è´ 1
                   GPU æ˜¾å­˜ YUV
                      â†“ ç€è‰²å™¨è½¬æ¢
                   GPU æ˜¾å­˜ RGB
                      â†“ æ‹·è´ 2
                   æ˜¾ç¤ºç¼“å†²åŒº

ç¡¬ä»¶è§£ç  + é›¶æ‹·è´æµç¨‹ï¼ˆ0 æ¬¡æ‹·è´ï¼‰ï¼š
è§†é¢‘æ–‡ä»¶ â†’ [GPU è§£ç ] â†’ GPU æ˜¾å­˜ YUV
                           â†“ ç€è‰²å™¨è½¬æ¢ï¼ˆåŒä¸€å—æ˜¾å­˜ï¼‰
                        GPU æ˜¾å­˜ RGB
                           â†“ ç›´æ¥æ˜¾ç¤º
                        æ˜¾ç¤ºç¼“å†²åŒº

æ€§èƒ½å·®å¼‚ï¼š
- 1080p @ 60fpsï¼šèŠ‚çœ ~250 MB/s å¸¦å®½
- 4K @ 60fpsï¼šèŠ‚çœ ~1 GB/s å¸¦å®½
```

---

## ç¬¬äº”ç« ï¼šæ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 5.1 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

#### 1080p @ 30fps è§†é¢‘

| æŒ‡æ ‡ | è½¯ä»¶æ¸²æŸ“ | ç¡¬ä»¶æ¸²æŸ“ï¼ˆæœ‰æ‹·è´ï¼‰ | ç¡¬ä»¶æ¸²æŸ“ï¼ˆé›¶æ‹·è´ï¼‰ |
|------|---------|-------------------|-------------------|
| **CPU å ç”¨** | 30-50% | 10-15% | 5-8% |
| **GPU å ç”¨** | 5% | 20-30% | 15-20% |
| **å†…å­˜å¸¦å®½** | 500 MB/s | 250 MB/s | 50 MB/s |
| **å»¶è¿Ÿ** | 20-30 ms | 10-15 ms | 5-8 ms |
| **åŠŸè€—** | 15-20 W | 10-12 W | 8-10 W |

#### 4K @ 60fps è§†é¢‘

| æŒ‡æ ‡ | è½¯ä»¶æ¸²æŸ“ | ç¡¬ä»¶æ¸²æŸ“ï¼ˆé›¶æ‹·è´ï¼‰ |
|------|---------|-------------------|
| **CPU å ç”¨** | 80-100% âŒ | 8-12% âœ… |
| **èƒ½å¦æµç•…æ’­æ”¾** | âŒ å¦ | âœ… æ˜¯ |
| **åŠŸè€—** | 30-40 W | 12-15 W |

### 5.2 æ€§èƒ½åˆ†æå·¥å…·

#### Windows GPU æ€§èƒ½ç›‘æ§

```cpp
// PIX (Performance Investigator for Xbox)
// ä¸‹è½½ï¼šhttps://devblogs.microsoft.com/pix/download/

// ä½¿ç”¨æ­¥éª¤ï¼š
// 1. å¯åŠ¨ PIX
// 2. é€‰æ‹©ä½ çš„ç¨‹åº
// 3. ç‚¹å‡»"Start GPU Capture"
// 4. æ’­æ”¾è§†é¢‘
// 5. æŸ¥çœ‹ GPU æ—¶é—´çº¿
```

#### CPU æ€§èƒ½åˆ†æ

```cpp
// Visual Studio Profiler
// èœå•ï¼šDebug â†’ Performance Profiler â†’ CPU Usage

// å…³æ³¨ï¼š
// - YUV â†’ RGB è½¬æ¢å‡½æ•°çš„è€—æ—¶
// - SDL_UpdateTexture çš„è€—æ—¶
// - å†…å­˜æ‹·è´çš„è€—æ—¶
```

### 5.3 ä¼˜åŒ–æŠ€å·§

#### è½¯ä»¶æ¸²æŸ“ä¼˜åŒ–

```cpp
// æŠ€å·§ 1ï¼šä½¿ç”¨ SIMD æŒ‡ä»¤ï¼ˆä¸€æ¬¡å¤„ç†å¤šä¸ªåƒç´ ï¼‰
#include <immintrin.h>  // AVX2

void ConvertYUVtoRGB_SIMD(uint8_t* yuv, uint8_t* rgb, int count) {
    for (int i = 0; i < count; i += 8) {  // ä¸€æ¬¡å¤„ç† 8 ä¸ªåƒç´ 
        __m256i y = _mm256_loadu_si256((__m256i*)(yuv + i));
        // ... SIMD è½¬æ¢
        _mm256_storeu_si256((__m256i*)(rgb + i * 3), result);
    }
}
// æ€§èƒ½æå‡ï¼š2-4 å€
```

```cpp
// æŠ€å·§ 2ï¼šå¤šçº¿ç¨‹å¹¶è¡Œå¤„ç†
void ConvertYUVtoRGB_Parallel(AVFrame* frame) {
    int num_threads = std::thread::hardware_concurrency();
    std::vector<std::thread> threads;
    
    int rows_per_thread = frame->height / num_threads;
    for (int i = 0; i < num_threads; i++) {
        threads.emplace_back([&, i]() {
            int start_row = i * rows_per_thread;
            int end_row = (i == num_threads - 1) ? frame->height : start_row + rows_per_thread;
            ConvertRows(frame, start_row, end_row);
        });
    }
    
    for (auto& t : threads) t.join();
}
// æ€§èƒ½æå‡ï¼š3-6 å€ï¼ˆå–å†³äºæ ¸å¿ƒæ•°ï¼‰
```

#### ç¡¬ä»¶æ¸²æŸ“ä¼˜åŒ–

```cpp
// æŠ€å·§ 1ï¼šä½¿ç”¨çº¹ç†ç¼“å­˜
std::unordered_map<int, ID3D11Texture2D*> texture_cache_;

ID3D11Texture2D* GetTexture(int width, int height) {
    int key = (width << 16) | height;
    if (texture_cache_.find(key) == texture_cache_.end()) {
        // åˆ›å»ºæ–°çº¹ç†
        texture_cache_[key] = CreateTexture(width, height);
    }
    return texture_cache_[key];
}
// é¿å…é¢‘ç¹åˆ›å»º/é”€æ¯çº¹ç†
```

```cpp
// æŠ€å·§ 2ï¼šä½¿ç”¨çº¹ç†æ•°ç»„ï¼ˆå‡å°‘ç»‘å®šæ¬¡æ•°ï¼‰
D3D11_TEXTURE2D_DESC desc = {};
desc.Width = 1920;
desc.Height = 1080;
desc.ArraySize = 3;  // Y, U, V æ”¾åœ¨ä¸€ä¸ªçº¹ç†æ•°ç»„ä¸­
desc.Format = DXGI_FORMAT_R8_UNORM;

ID3D11Texture2D* yuvTextureArray;
device->CreateTexture2D(&desc, nullptr, &yuvTextureArray);

// ç€è‰²å™¨ä¸­ï¼š
// Texture2DArray yuvTextures : register(t0);
// float y = yuvTextures.Sample(sampler, float3(texCoord, 0)).r;
// float u = yuvTextures.Sample(sampler, float3(texCoord, 1)).r;
// float v = yuvTextures.Sample(sampler, float3(texCoord, 2)).r;
```

---

## ç¬¬å…­ç« ï¼šZenPlay å®ç°

### 6.1 æ¶æ„æ¦‚è§ˆ

```
ZenPlayerï¼ˆæ’­æ”¾å™¨æ§åˆ¶ï¼‰
    â†“
RenderPathSelectorï¼ˆæ¸²æŸ“è·¯å¾„é€‰æ‹©å™¨ï¼‰
    â†“ æ£€æµ‹ç¡¬ä»¶èƒ½åŠ›
    â”œâ”€â†’ è½¯ä»¶è·¯å¾„
    â”‚   â”œâ”€ FFmpeg è½¯ä»¶è§£ç  (CPU)
    â”‚   â””â”€ SDLRenderer (SDL2 è½¯ä»¶æ¸²æŸ“)
    â”‚
    â””â”€â†’ ç¡¬ä»¶è·¯å¾„
        â”œâ”€ FFmpeg ç¡¬ä»¶è§£ç  (GPU D3D11VA/DXVA2)
        â”‚  â””â”€ HWDecoderContextï¼ˆç¡¬ä»¶è§£ç ä¸Šä¸‹æ–‡ï¼‰
        â””â”€ D3D11Renderer (Direct3D 11 ç¡¬ä»¶æ¸²æŸ“)
           â”œâ”€ D3D11Contextï¼ˆè®¾å¤‡ç®¡ç†ï¼‰
           â”œâ”€ D3D11Textureï¼ˆçº¹ç†ç®¡ç†ï¼‰
           â””â”€ D3D11Shaderï¼ˆç€è‰²å™¨ç®¡ç†ï¼‰
```

### 6.2 å…³é”®ç±»è¯¦è§£

#### 6.2.1 Rendererï¼ˆæ¸²æŸ“å™¨æŠ½è±¡æ¥å£ï¼‰

```cpp
// src/player/video/render/renderer.h

class Renderer {
 public:
  virtual ~Renderer() = default;
  
  // åˆå§‹åŒ–æ¸²æŸ“å™¨
  virtual Result<void> Init(HWND window, int width, int height) = 0;
  
  // æ¸²æŸ“ä¸€å¸§
  virtual Result<void> RenderFrame(AVFrame* frame) = 0;
  
  // è°ƒæ•´å¤§å°
  virtual Result<void> Resize(int width, int height) = 0;
  
  // æ¸…ç†èµ„æº
  virtual void Cleanup() = 0;
};
```

**ä¸ºä»€ä¹ˆéœ€è¦æŠ½è±¡æ¥å£**ï¼Ÿ
- å¯ä»¥è½»æ¾åˆ‡æ¢è½¯ä»¶/ç¡¬ä»¶æ¸²æŸ“
- æœªæ¥æ”¯æŒå…¶ä»–å¹³å°ï¼ˆLinuxã€macOSï¼‰
- ä¾¿äºæµ‹è¯•å’Œ Mock

#### 6.2.2 SDLRendererï¼ˆè½¯ä»¶æ¸²æŸ“å®ç°ï¼‰

```cpp
// src/player/video/render/impl/sdl_renderer.h

class SDLRenderer : public Renderer {
 public:
  Result<void> Init(HWND window, int width, int height) override {
    // 1. åˆ›å»º SDL çª—å£
    sdl_window_ = SDL_CreateWindowFrom(window);
    
    // 2. åˆ›å»º SDL æ¸²æŸ“å™¨
    sdl_renderer_ = SDL_CreateRenderer(sdl_window_, -1, 
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    
    // 3. åˆ›å»º YUV çº¹ç†
    sdl_texture_ = SDL_CreateTexture(sdl_renderer_,
        SDL_PIXELFORMAT_IYUV,
        SDL_TEXTUREACCESS_STREAMING,
        width, height);
    
    return Result<void>::Ok();
  }
  
  Result<void> RenderFrame(AVFrame* frame) override {
    // 1. æ›´æ–° YUV çº¹ç†ï¼ˆCPU â†’ GPU æ‹·è´ï¼‰
    SDL_UpdateYUVTexture(sdl_texture_, nullptr,
        frame->data[0], frame->linesize[0],  // Y
        frame->data[1], frame->linesize[1],  // U
        frame->data[2], frame->linesize[2]); // V
    
    // 2. æ¸²æŸ“åˆ°çª—å£
    SDL_RenderClear(sdl_renderer_);
    SDL_RenderCopy(sdl_renderer_, sdl_texture_, nullptr, nullptr);
    SDL_RenderPresent(sdl_renderer_);
    
    return Result<void>::Ok();
  }
  
 private:
  SDL_Window* sdl_window_ = nullptr;
  SDL_Renderer* sdl_renderer_ = nullptr;
  SDL_Texture* sdl_texture_ = nullptr;
};
```

#### 6.2.3 D3D11Rendererï¼ˆç¡¬ä»¶æ¸²æŸ“å®ç°ï¼‰

```cpp
// src/player/video/render/impl/d3d11_renderer.h

class D3D11Renderer : public Renderer {
 public:
  Result<void> Init(HWND window, int width, int height) override {
    // 1. åˆå§‹åŒ– D3D11 ä¸Šä¸‹æ–‡
    auto result = d3d11_context_->Initialize(nullptr);
    if (!result.IsOk()) return result;
    
    // 2. åˆ›å»ºäº¤æ¢é“¾ï¼ˆæ˜¾ç¤ºåˆ°çª—å£ï¼‰
    CreateSwapChain(window, width, height);
    
    // 3. ç¼–è¯‘ç€è‰²å™¨
    CompileShaders();
    
    // 4. åˆ›å»ºçº¹ç†
    CreateTextures(width, height);
    
    return Result<void>::Ok();
  }
  
  Result<void> RenderFrame(AVFrame* frame) override {
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç¡¬ä»¶è§£ç å¸§ï¼ˆé›¶æ‹·è´ï¼‰
    if (frame->format == AV_PIX_FMT_D3D11) {
      return RenderHardwareFrame(frame);  // é›¶æ‹·è´è·¯å¾„
    } else {
      return RenderSoftwareFrame(frame);  // éœ€è¦ä¸Šä¼ 
    }
  }
  
 private:
  Result<void> RenderHardwareFrame(AVFrame* frame) {
    // é›¶æ‹·è´ï¼šç›´æ¥ä½¿ç”¨ç¡¬ä»¶è§£ç è¾“å‡ºçš„çº¹ç†
    ID3D11Texture2D* texture = (ID3D11Texture2D*)frame->data[0];
    int index = (intptr_t)frame->data[1];
    
    // ç»‘å®šåˆ°ç€è‰²å™¨
    ID3D11ShaderResourceView* srv;
    device_->CreateShaderResourceView(texture, nullptr, &srv);
    context_->PSSetShaderResources(0, 1, &srv);
    
    // è¿è¡Œç€è‰²å™¨å¹¶æ¸²æŸ“
    DrawFullscreenQuad();
    
    // å‘ˆç°åˆ°çª—å£
    swap_chain_->Present(1, 0);
    
    srv->Release();
    return Result<void>::Ok();
  }
  
  Result<void> RenderSoftwareFrame(AVFrame* frame) {
    // éœ€è¦ä¸Šä¼ ï¼šä» CPU å†…å­˜å¤åˆ¶åˆ° GPU
    context_->UpdateSubresource(y_texture_, 0, nullptr,
        frame->data[0], frame->linesize[0], 0);
    context_->UpdateSubresource(u_texture_, 0, nullptr,
        frame->data[1], frame->linesize[1], 0);
    context_->UpdateSubresource(v_texture_, 0, nullptr,
        frame->data[2], frame->linesize[2], 0);
    
    // åç»­å’Œç¡¬ä»¶å¸§ä¸€æ ·
    // ...
  }
  
  std::unique_ptr<D3D11Context> d3d11_context_;
  ID3D11Texture2D* y_texture_ = nullptr;
  ID3D11Texture2D* u_texture_ = nullptr;
  ID3D11Texture2D* v_texture_ = nullptr;
  ID3D11PixelShader* yuv_to_rgb_shader_ = nullptr;
  IDXGISwapChain* swap_chain_ = nullptr;
};
```

#### 6.2.4 HWDecoderContextï¼ˆç¡¬ä»¶è§£ç ä¸Šä¸‹æ–‡ï¼‰

```cpp
// src/player/codec/hw_decoder_context.h

class HWDecoderContext {
 public:
  Result<void> Initialize(bool allow_d3d11va, bool allow_dxva2) {
    // 1. åˆ›å»º D3D11 ç¡¬ä»¶è®¾å¤‡ä¸Šä¸‹æ–‡
    if (allow_d3d11va) {
      int ret = av_hwdevice_ctx_create(&hw_device_ctx_,
          AV_HWDEVICE_TYPE_D3D11VA, nullptr, nullptr, 0);
      if (ret >= 0) {
        hw_device_type_ = AV_HWDEVICE_TYPE_D3D11VA;
        return Result<void>::Ok();
      }
    }
    
    // 2. é™çº§åˆ° DXVA2ï¼ˆWindows 7ï¼‰
    if (allow_dxva2) {
      int ret = av_hwdevice_ctx_create(&hw_device_ctx_,
          AV_HWDEVICE_TYPE_DXVA2, nullptr, nullptr, 0);
      if (ret >= 0) {
        hw_device_type_ = AV_HWDEVICE_TYPE_DXVA2;
        return Result<void>::Ok();
      }
    }
    
    return Result<void>::Err(ErrorCode::kHardwareNotSupported,
        "No hardware decoder available");
  }
  
  AVBufferRef* GetHWDeviceContext() { return hw_device_ctx_; }
  
  // å…±äº« D3D11 è®¾å¤‡ï¼ˆæ¸²æŸ“å™¨å’Œè§£ç å™¨ä½¿ç”¨åŒä¸€ä¸ª GPU è®¾å¤‡ï¼‰
  void SetSharedD3D11Device(ID3D11Device* device) {
    if (hw_device_type_ == AV_HWDEVICE_TYPE_D3D11VA) {
      AVHWDeviceContext* hw_ctx = (AVHWDeviceContext*)hw_device_ctx_->data;
      AVD3D11VADeviceContext* d3d11_ctx = (AVD3D11VADeviceContext*)hw_ctx->hwctx;
      d3d11_ctx->device = device;
      device->AddRef();
    }
  }
  
 private:
  AVBufferRef* hw_device_ctx_ = nullptr;
  AVHWDeviceType hw_device_type_;
};
```

### 6.3 æ¸²æŸ“è·¯å¾„é€‰æ‹©é€»è¾‘

```cpp
// src/player/zen_player.cpp

Result<void> ZenPlayer::InitializeRenderPath() {
  auto& config = ConfigManager::Instance();
  
  // 1. æ£€æŸ¥é…ç½®
  bool enable_hw = config.GetBool("render.use_hardware_acceleration", true);
  if (!enable_hw) {
    return InitializeSoftwarePath();
  }
  
  // 2. æ£€æŸ¥ç¡¬ä»¶èƒ½åŠ›
  if (!CheckHardwareCapability()) {
    MODULE_WARN(LOG_MODULE_PLAYER, "Hardware not supported");
    return InitializeSoftwarePath();
  }
  
  // 3. å°è¯•åˆå§‹åŒ–ç¡¬ä»¶è·¯å¾„
  auto hw_result = InitializeHardwarePath();
  if (!hw_result.IsOk()) {
    // 4. é™çº§åˆ°è½¯ä»¶è·¯å¾„
    bool allow_fallback = config.GetBool("render.hardware.allow_fallback", true);
    if (allow_fallback) {
      MODULE_WARN(LOG_MODULE_PLAYER, "Hardware init failed, fallback to software");
      return InitializeSoftwarePath();
    }
    return hw_result;
  }
  
  MODULE_INFO(LOG_MODULE_PLAYER, "Using hardware render path");
  return Result<void>::Ok();
}
```

---

## ç¬¬ä¸ƒç« ï¼šå®æˆ˜æ¼”ç»ƒ

### 7.1 ä»é›¶å®ç°ä¸€ä¸ªç®€å•çš„ SDL è½¯ä»¶æ¸²æŸ“å™¨

```cpp
// simple_sdl_renderer.cpp

#include <SDL2/SDL.h>
#include <iostream>

extern "C" {
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cout << "Usage: " << argv[0] << " <video_file>" << std::endl;
        return 1;
    }
    
    // ========== ç¬¬ä¸€æ­¥ï¼šåˆå§‹åŒ– SDL ==========
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window* window = SDL_CreateWindow("Simple Player",
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
        1280, 720, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1,
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    
    // ========== ç¬¬äºŒæ­¥ï¼šæ‰“å¼€è§†é¢‘æ–‡ä»¶ ==========
    AVFormatContext* format_ctx = nullptr;
    avformat_open_input(&format_ctx, argv[1], nullptr, nullptr);
    avformat_find_stream_info(format_ctx, nullptr);
    
    // æ‰¾åˆ°è§†é¢‘æµ
    int video_stream_index = -1;
    for (int i = 0; i < format_ctx->nb_streams; i++) {
        if (format_ctx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
            video_stream_index = i;
            break;
        }
    }
    
    // ========== ç¬¬ä¸‰æ­¥ï¼šåˆå§‹åŒ–è§£ç å™¨ ==========
    AVCodecParameters* codec_params = format_ctx->streams[video_stream_index]->codecpar;
    AVCodec* codec = avcodec_find_decoder(codec_params->codec_id);
    AVCodecContext* codec_ctx = avcodec_alloc_context3(codec);
    avcodec_parameters_to_context(codec_ctx, codec_params);
    avcodec_open2(codec_ctx, codec, nullptr);
    
    // ========== ç¬¬å››æ­¥ï¼šåˆ›å»º SDL çº¹ç† ==========
    SDL_Texture* texture = SDL_CreateTexture(renderer,
        SDL_PIXELFORMAT_IYUV,
        SDL_TEXTUREACCESS_STREAMING,
        codec_ctx->width, codec_ctx->height);
    
    // ========== ç¬¬äº”æ­¥ï¼šè§£ç å’Œæ¸²æŸ“å¾ªç¯ ==========
    AVPacket* packet = av_packet_alloc();
    AVFrame* frame = av_frame_alloc();
    
    bool quit = false;
    SDL_Event event;
    
    while (!quit && av_read_frame(format_ctx, packet) >= 0) {
        // å¤„ç† SDL äº‹ä»¶
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                quit = true;
            }
        }
        
        if (packet->stream_index == video_stream_index) {
            // å‘é€æ•°æ®åŒ…åˆ°è§£ç å™¨
            avcodec_send_packet(codec_ctx, packet);
            
            // æ¥æ”¶è§£ç åçš„å¸§
            while (avcodec_receive_frame(codec_ctx, frame) == 0) {
                // ğŸ¯ æ¸²æŸ“å…³é”®æ­¥éª¤ï¼šæ›´æ–° YUV çº¹ç†
                SDL_UpdateYUVTexture(texture, nullptr,
                    frame->data[0], frame->linesize[0],  // Y å¹³é¢
                    frame->data[1], frame->linesize[1],  // U å¹³é¢
                    frame->data[2], frame->linesize[2]); // V å¹³é¢
                
                // æ¸²æŸ“åˆ°çª—å£
                SDL_RenderClear(renderer);
                SDL_RenderCopy(renderer, texture, nullptr, nullptr);
                SDL_RenderPresent(renderer);
                
                // ç®€å•çš„å¸§ç‡æ§åˆ¶
                SDL_Delay(33);  // ~30 fps
            }
        }
        
        av_packet_unref(packet);
    }
    
    // ========== ç¬¬å…­æ­¥ï¼šæ¸…ç†èµ„æº ==========
    av_frame_free(&frame);
    av_packet_free(&packet);
    avcodec_free_context(&codec_ctx);
    avformat_close_input(&format_ctx);
    
    SDL_DestroyTexture(texture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    
    return 0;
}
```

**ç¼–è¯‘å‘½ä»¤**ï¼š
```bash
g++ simple_sdl_renderer.cpp -o simple_player \
    -lavcodec -lavformat -lavutil \
    -lSDL2 \
    -std=c++17
```

### 7.2 æµ‹é‡è½¯ä»¶æ¸²æŸ“æ€§èƒ½

```cpp
// benchmark_software_rendering.cpp

#include <chrono>
#include <iostream>

void BenchmarkYUVtoRGB() {
    const int width = 1920;
    const int height = 1080;
    const int iterations = 100;
    
    // åˆ†é…å†…å­˜
    uint8_t* yuv_data = new uint8_t[width * height * 3 / 2];
    uint8_t* rgb_data = new uint8_t[width * height * 3];
    
    // å¡«å……æµ‹è¯•æ•°æ®
    memset(yuv_data, 128, width * height * 3 / 2);
    
    // æµ‹é‡è½¬æ¢æ—¶é—´
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int iter = 0; iter < iterations; iter++) {
        // YUV â†’ RGB è½¬æ¢
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int y_offset = y * width + x;
                int uv_offset = (y / 2) * (width / 2) + (x / 2);
                
                int Y = yuv_data[y_offset];
                int U = yuv_data[width * height + uv_offset] - 128;
                int V = yuv_data[width * height * 5 / 4 + uv_offset] - 128;
                
                int rgb_offset = (y * width + x) * 3;
                rgb_data[rgb_offset + 0] = CLIP(Y + 1.402 * V);
                rgb_data[rgb_offset + 1] = CLIP(Y - 0.344 * U - 0.714 * V);
                rgb_data[rgb_offset + 2] = CLIP(Y + 1.772 * U);
            }
        }
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // è®¡ç®—æ€§èƒ½
    double avg_time = duration.count() / (double)iterations;
    double fps = 1000.0 / avg_time;
    
    std::cout << "1080p YUVâ†’RGB è½¬æ¢æ€§èƒ½:" << std::endl;
    std::cout << "  å¹³å‡è€—æ—¶: " << avg_time << " ms/å¸§" << std::endl;
    std::cout << "  ç­‰æ•ˆå¸§ç‡: " << fps << " fps" << std::endl;
    std::cout << "  åƒç´ åå: " << (width * height * fps / 1000000.0) << " Måƒç´ /ç§’" << std::endl;
    
    delete[] yuv_data;
    delete[] rgb_data;
}

int main() {
    BenchmarkYUVtoRGB();
    return 0;
}
```

### 7.3 è°ƒè¯•ç¡¬ä»¶æ¸²æŸ“

```cpp
// å¸¸è§é—®é¢˜æ’æŸ¥

// é—®é¢˜ 1ï¼šé»‘å±
// åŸå› ï¼šçº¹ç†æœªæ­£ç¡®ä¸Šä¼ æˆ–ç€è‰²å™¨æœ‰é—®é¢˜
// è§£å†³ï¼š
// 1. æ£€æŸ¥çº¹ç†æ ¼å¼æ˜¯å¦åŒ¹é…
D3D11_TEXTURE2D_DESC desc;
texture->GetDesc(&desc);
std::cout << "Texture format: " << desc.Format << std::endl;

// 2. éªŒè¯æ•°æ®æ˜¯å¦ä¸Šä¼ 
D3D11_MAPPED_SUBRESOURCE mapped;
context->Map(texture, 0, D3D11_MAP_READ, 0, &mapped);
uint8_t* data = (uint8_t*)mapped.pData;
std::cout << "First pixel Y value: " << (int)data[0] << std::endl;
context->Unmap(texture, 0);

// é—®é¢˜ 2ï¼šé¢œè‰²ä¸å¯¹
// åŸå› ï¼šYUV â†’ RGB è½¬æ¢å…¬å¼é”™è¯¯
// è§£å†³ï¼šä½¿ç”¨æ ‡å‡† BT.709 ç³»æ•°
const float3x3 yuv_to_rgb_matrix = {
    1.0,  0.0,     1.5748,
    1.0, -0.1873, -0.4681,
    1.0,  1.8556,  0.0
};

// é—®é¢˜ 3ï¼šæ€§èƒ½ä¸å¦‚é¢„æœŸ
// æ’æŸ¥ï¼š
// 1. æ˜¯å¦çœŸçš„ä½¿ç”¨äº†ç¡¬ä»¶è§£ç ï¼Ÿ
if (frame->format == AV_PIX_FMT_D3D11) {
    std::cout << "âœ… ç¡¬ä»¶è§£ç " << std::endl;
} else {
    std::cout << "âŒ è½¯ä»¶è§£ç ï¼Œæ€§èƒ½ä¼šå·®" << std::endl;
}

// 2. æ˜¯å¦æœ‰ä¸å¿…è¦çš„æ‹·è´ï¼Ÿ
// é›¶æ‹·è´ï¼šframe->data[0] åº”è¯¥ç›´æ¥æ˜¯ ID3D11Texture2D*
// æœ‰æ‹·è´ï¼šéœ€è¦è°ƒç”¨ UpdateSubresource
```

---

## ğŸ“š å­¦ä¹ èµ„æºæ¨è

### åŸºç¡€çŸ¥è¯†
1. **LearnOpenGL**ï¼šhttps://learnopengl.com/ ï¼ˆç†è§£ GPU æ¸²æŸ“åŸç†ï¼‰
2. **DirectX Tutorial**ï¼šhttps://docs.microsoft.com/directx ï¼ˆå­¦ä¹  D3D11ï¼‰
3. **FFmpeg å®˜æ–¹æ–‡æ¡£**ï¼šhttps://ffmpeg.org/documentation.html

### è¿›é˜¶èµ„æº
1. **RenderDoc**ï¼šGPU è°ƒè¯•å·¥å…·ï¼Œå¯è§†åŒ–æ¸²æŸ“è¿‡ç¨‹
2. **PIX**ï¼šWindows GPU æ€§èƒ½åˆ†æå·¥å…·
3. **Nvidia Nsight**ï¼šæ·±åº¦ GPU æ€§èƒ½åˆ†æ

### è§†é¢‘æ•™ç¨‹
1. **YouTube - The Cherno**ï¼šC++ æ¸¸æˆå¼•æ“ç³»åˆ—ï¼ˆæ¸²æŸ“éƒ¨åˆ†ï¼‰
2. **YouTube - javidx9**ï¼šä»é›¶å®ç°è½¯ä»¶æ¸²æŸ“å™¨

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µå›é¡¾

1. **æ¸²æŸ“çš„æœ¬è´¨**ï¼šæŠŠè§†é¢‘å¸§ï¼ˆYUVï¼‰è½¬æ¢å¹¶æ˜¾ç¤ºåˆ°å±å¹•ï¼ˆRGBï¼‰

2. **ä¸¤ç§æ¸²æŸ“æ–¹å¼**ï¼š
   - è½¯ä»¶æ¸²æŸ“ï¼šCPU å¤„ç†ï¼Œæ…¢ä½†å…¼å®¹æ€§å¥½
   - ç¡¬ä»¶æ¸²æŸ“ï¼šGPU å¤„ç†ï¼Œå¿«ä½†éœ€è¦ç¡¬ä»¶æ”¯æŒ

3. **æ€§èƒ½å·®å¼‚**ï¼š
   - è½¯ä»¶æ¸²æŸ“ï¼š1080p å ç”¨ 30-50% CPU
   - ç¡¬ä»¶æ¸²æŸ“ï¼š1080p å ç”¨ 5-8% CPU

4. **é›¶æ‹·è´çš„å…³é”®**ï¼š
   - ç¡¬ä»¶è§£ç ç›´æ¥è¾“å‡º GPU çº¹ç†
   - æ¸²æŸ“å™¨ç›´æ¥ä½¿ç”¨è¯¥çº¹ç†
   - é¿å… CPU â†” GPU æ•°æ®ä¼ è¾“

5. **ZenPlay çš„è®¾è®¡**ï¼š
   - æŠ½è±¡æ¥å£ï¼ˆRendererï¼‰
   - ä¸¤ç§å®ç°ï¼ˆSDLRenderer / D3D11Rendererï¼‰
   - è‡ªåŠ¨é€‰æ‹©å’Œé™çº§

### å­¦ä¹ è·¯å¾„å»ºè®®

```
ç¬¬ 1 å‘¨ï¼šç†è§£åŸºç¡€æ¦‚å¿µ
- YUV vs RGB
- ä»€ä¹ˆæ˜¯å¸§ã€å¸§ç‡
- è½¯ä»¶æ¸²æŸ“æµç¨‹

ç¬¬ 2 å‘¨ï¼šå®è·µè½¯ä»¶æ¸²æŸ“
- ç”¨ SDL2 å®ç°ç®€å•æ’­æ”¾å™¨
- æµ‹é‡æ€§èƒ½
- ä¼˜åŒ–ï¼ˆSIMDã€å¤šçº¿ç¨‹ï¼‰

ç¬¬ 3 å‘¨ï¼šå­¦ä¹  GPU åŸç†
- ç€è‰²å™¨åŸºç¡€
- Direct3D 11 / OpenGL å…¥é—¨
- çº¹ç†å’Œé‡‡æ ·

ç¬¬ 4 å‘¨ï¼šå®ç°ç¡¬ä»¶æ¸²æŸ“
- D3D11 è®¾å¤‡å’Œä¸Šä¸‹æ–‡
- åˆ›å»ºçº¹ç†
- ç¼–å†™ YUV â†’ RGB ç€è‰²å™¨

ç¬¬ 5 å‘¨ï¼šé›†æˆç¡¬ä»¶è§£ç 
- FFmpeg ç¡¬ä»¶è§£ç  API
- D3D11VA é…ç½®
- é›¶æ‹·è´æµæ°´çº¿

ç¬¬ 6 å‘¨ï¼šä¼˜åŒ–å’Œè°ƒè¯•
- ä½¿ç”¨ RenderDoc è°ƒè¯•
- æ€§èƒ½åˆ†æ
- å¤šåˆ†è¾¨ç‡æµ‹è¯•
```

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **é˜…è¯» ZenPlay æºç **ï¼š
   - `src/player/video/render/renderer.h`
   - `src/player/video/render/impl/sdl_renderer.cpp`
   - `src/player/video/render/impl/d3d11_renderer.cpp`

2. **è¿è¡Œç¤ºä¾‹**ï¼š
   - ç¼–è¯‘å¹¶è¿è¡Œ `simple_sdl_renderer.cpp`
   - å¯¹æ¯”è½¯ä»¶/ç¡¬ä»¶æ¸²æŸ“æ€§èƒ½

3. **å®éªŒ**ï¼š
   - ä¿®æ”¹ç€è‰²å™¨ä»£ç ï¼ˆæ”¹å˜é¢œè‰²ï¼‰
   - æ·»åŠ æ€§èƒ½ç»Ÿè®¡
   - å®ç°æˆªå›¾åŠŸèƒ½

---

**ç¥å­¦ä¹ æ„‰å¿«ï¼å¦‚æœ‰ç–‘é—®ï¼Œéšæ—¶æé—®ã€‚** ğŸš€
