// Loki线程框架使用说明

## Loki线程类型和用途

### 1. UI线程 (loki::ID::UI)
- **用途**: UI更新、用户交互处理、短时间的UI相关任务
- **特点**: 与Qt主线程集成，不能被长时间阻塞
- **适合**: 
  - 状态更新通知
  - 定时渲染任务调度
  - UI事件处理
- **不适合**: 长时间运行的阻塞操作

### 2. IO线程 (loki::ID::IO) 
- **用途**: 异步IO操作、网络请求、文件元数据操作
- **特点**: 专门处理非阻塞或短时间的IO操作
- **适合**:
  - 网络请求
  - 文件打开/关闭
  - 目录遍历
  - 元数据读取
- **不适合**: 持续的数据流读取(如av_read_frame)

### 3. 其他预定义线程 (NET, DB等)
- **用途**: 特定领域的异步任务
- **特点**: 任务调度，不适合长期占用

## 正确的线程架构

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   UI Thread     │    │  Worker Threads  │    │ Loki Task Pool  │
│   (loki::UI)    │    │  (std::thread)   │    │ (IO/NET/DB)    │
├─────────────────┤    ├──────────────────┤    ├─────────────────┤
│ • UI更新        │    │ • 解封装循环     │    │ • 异步IO       │
│ • 用户交互      │    │ • 视频解码循环   │    │ • 网络请求     │
│ • 渲染调度      │    │ • 音频解码循环   │    │ • 文件操作     │
│ • 状态通知      │    │ • 长时间处理     │    │ • 短任务       │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

## 数据流向
```
文件 → [Demux Worker Thread] → Packet Queue → [Decode Worker Threads] → Frame Queue → [UI Thread Render Task]
```

## 为什么这样设计？
1. **解封装**: av_read_frame是阻塞调用，需要持续运行，用worker thread
2. **解码**: 同样是持续的处理循环，用worker thread  
3. **渲染**: 定时任务，与UI同步，用loki::UI线程调度
4. **IO操作**: 文件打开、seek等非持续操作，可以用loki::IO

这样既充分利用了loki的任务调度能力，又避免了阻塞其线程池。
